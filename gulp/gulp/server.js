/* eslint-env node, es6 */
const browserSync = require('browser-sync');
const fs = require('fs-extra');
const {stripIndents} = require('common-tags');
const opn = require('opn');
const log = require('fancy-log');
const webpack = require('webpack');
const exitHook = require('async-exit-hook');
const webpackDevMiddleware = require('webpack-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');
const webpackConfig = require('../webpack.config.js');
const {phpMiddleware} = require('../lib/php');
const {setHost, themeConfig, getHostFromDb, destroyDbConnection} = require('../lib/shopware');
const {getHost, getPort} = require('../lib/network');
const {tmpl, DOCROOT, TMP} = require('../lib/dir');
const {isProd, getOption, getEnv} = require('../lib/env');
const pkg = require('../../package.json');

const watchOptions = getOption('docker')
  ? {
      usePolling: true,
      interval: 500,
      alwaysStat: true,
    }
  : {};

/**
 * Browsersync config based on env
 */
const options = {
  server: {},
  watchTask: !isProd(),
  notify: !isProd(),
  host: getHost(),
  open: false,
  watchOptions: watchOptions,
  ghostMode: {
    clicks: true,
    scroll: true,
    links: true,
    forms: true,
  },
};

/**
 * Browsersync instance
 */
const instanceName = pkg.name || 'shopware';
const bs = browserSync.create(instanceName);

/**
 * Get server base dir
 * @returns {Promise}
 */
const getBaseDir = () => {
  if (isProd()) {
    return Promise.resolve(tmpl.path({folder: DOCROOT}));
  }

  return themeConfig().then(({inheritancePath}) => [
    tmpl.path({folder: TMP}),
    tmpl.path('frontend/_resources', {folder: TMP}),
    ...inheritancePath.map(theme => tmpl.path(`themes/Frontend/${theme}/frontend/_public/src`, {folder: DOCROOT})),
    tmpl.path({folder: DOCROOT}),
  ]);
};

/**
 * Write empty service-worker to be delivered in dev mode
 * so we don't end up with cached content
 * @returns {*}
 */
const writeServiceWorkerMock = () => {
  if (isProd()) {
    return Promise.resolve();
  }

  return fs.outputFile(
    tmpl.path('service-worker.js', {folder: TMP}),
    stripIndents` 
      // This file is intentionally without code.
      // It's present so that service worker registration will work when serving from the 'src' directory.
      // The version of service-worker.js that's present in the 'dist' directory is automatically
      // generated by the 'generate-service-worker' gulp task, and contains code to precache resources.
  `
  );
};

/**
 * Destroy connection and kill process
 * @param {string} host Original host to reset the db to
 * @param {function} done Done callback
 * @return {*}
 */
const destroy = (host = getEnv('host'), done = function() {}) => {
  bs.exit();
  browserSync.get(instanceName).exit();
  browserSync.get(instanceName).cleanup();

  if (!host) {
    return destroyDbConnection().then(() => done());
  }

  setHost(host)
    .then(() => destroyDbConnection())
    .then(() => log(`Host has been reset to ${host}`))
    .then(() => done());
};

/**
 * Start browsersync server based on commandline args (proxy, shop, ...)
 * @param {object} overrides
 * @return {Promise<object>} Resolves to an object with the bs instance name, the url and a destroy method
 */
const runServer = (overrides = {}) => {
  const user = getOption('user');
  const pass = getOption('pass');
  const proxy = getOption('proxy');

  const getServerHost = proxy ? () => Promise.resolve(null) : getHostFromDb;
  const setServerHost = proxy ? () => Promise.resolve(null) : setHost;
  const preconditions = [webpackConfig(), getPort(8000), getBaseDir(), getServerHost(), writeServiceWorkerMock()];
  const {logLevel} = overrides;

  // Wait for all preconditions to be ready
  return Promise.all(preconditions).then(([webpackConfig, port, baseDir, originalHost]) => {
    let middleware = [];
    let https = false;

    if (!proxy) {
      const bundler = webpack(webpackConfig);
      middleware = [
        webpackDevMiddleware(bundler, {
          watchOptions: watchOptions,
          publicPath: webpackConfig.output.publicPath,
          stats: logLevel === 'silent' ? false : {colors: true},
          noInfo: logLevel === 'silent',
        }),
        webpackHotMiddleware(bundler),
      ];
    }

    const bsOptions = {
      ...options,
      port: port,
      server: {...options.server, baseDir},
      middleware: [...middleware, phpMiddleware()],
      ...overrides,
    };

    // Proxy configuration
    if (proxy) {
      if (user && pass) {
        bsOptions.proxy = {
          target: proxy,
          proxyReq: [
            function(proxyReq) {
              proxyReq.setHeader('Authorization', basic(user, pass));
            },
          ],
        };
      } else {
        bsOptions.proxy = proxy;
      }

      if (/https:\/\//.test(proxy)) {
        https = true;
      }

      bsOptions.host = getHost();
      bsOptions.https = false;
      bsOptions.watchTask = false;
      bsOptions.notify = false;
      delete bsOptions.server;
      delete bsOptions.middleware;
    }

    return new Promise((resolve, reject) => {
      bs.init(bsOptions, (err, instance) => {
        if (err) {
          destroy();
          reject(err);
        }

        const host = getOption('host') || instance.getOption('host');
        const port = getOption('port') || instance.getOption('port');

        // Add exit hook to restore database connection
        exitHook(done => destroy(originalHost, done));

        // Set shopware host configuration to browsersync server address
        setServerHost(host, port)
          .then(() =>
            resolve({
              instanceName,
              destroy: () => destroy(originalHost),
              proto: https ? 'https' : 'http',
              host,
              port,
              url: `${https ? 'https' : 'http'}://${host}:${port}`,
            })
          )
          .catch(err => destroy(originalHost, () => reject(err)));
      });
    });
  });
};

/**
 * Serve task based on environment
 */
const serve = () =>
  runServer().then(({url}) => {
    opn(url);
    console.log('Server running');
    return url;
  });

module.exports = {
  bs,
  runServer,
  serve
};
